using System;
using System.Collections.Generic;

public class CPHInline
{
    // ===== STATIC COMMANDS =====
    private static readonly Dictionary<string, string> CommandMap = new(StringComparer.OrdinalIgnoreCase)
    {
        // Global shuffle commands
        { "!WH shuffle", "!WH global_shuffle" },
        { "!WH shuffle_ai", "!WH global_shuffle_ai" },

        // Random war
        { "!WH random", "!WH random_war_declaration" },

        // Corruption effects by faction
        { "!WH nur", "!WH nur_corruption_effect_all" },
        { "!WH kho", "!WH kho_corruption_effect_all" },
        { "!WH sla", "!WH sla_corruption_effect_all" },
        { "!WH tze", "!WH tze_corruption_effect_all" },
        { "!WH skv", "!WH skv_corruption_effect_all" },
        { "!WH chs", "!WH chs_corruption_effect_all" },
        { "!WH vmp", "!WH vmp_corruption_effect_all" },
        { "!WH neu", "!WH neu_corruption_effect_all" },

        // Bonuses / Maluses
        { "!WH po_boni", "!WH po_boni_effect_all" },
        { "!WH po_mali", "!WH po_mali_effect_all" },
        { "!WH repl_boni", "!WH repl_boni_effect_all" },
        { "!WH repl_mali", "!WH repl_mali_effect_all" },

        // Peaks
        { "!WH peak10", "!WH peak_10" },
        { "!WH peak5", "!WH peak_5" },
        { "!WH peak2", "!WH peak_2" },
        { "!WH peak1", "!WH peak_1" },

        // Add more static chat commands here as needed
    };

    // ===== DYNAMIC COMMANDS =====
    private static readonly Dictionary<string, string> DynamicCommandMap = new(StringComparer.OrdinalIgnoreCase)
    {
        // Dynamic Commands -  change name here 
        // !!! Keep in mind that the !WH will still be infront even if not named here
        { "money", "toss_a_coin_{0}" },
        //{ "gold", "toss_a_coin_{0}" },    //Example for changing Command from: money to gold
        { "switcharoo", "switcharoo_{0}" },
        { "spawn_armies", "spawn_armies_{0}_{1}" },
        //{ "army", "spawn_armies_{0}_{1}" },    //Example for changing Command from: spawn_armies to army
    };

    // Faction canonical keys + synonyms
    private static readonly Dictionary<string, string> FactionMap = new(StringComparer.OrdinalIgnoreCase)
    {
        // Faction keys - DONT CHANGE THEM
        { "grn", "grn" }, { "ogr", "ogr" }, { "bst", "bst" }, { "nor", "nor" }, { "skv", "skv" },
        { "def", "def" }, { "chs", "chs" }, { "chd", "chd" }, { "brt", "brt" }, { "cth", "cth" },
        { "wef", "wef" }, { "lzd", "lzd" }, { "hef", "hef" }, { "ksl", "ksl" }, { "dwf", "dwf" },
        { "emp", "emp" }, { "nur", "nur" }, { "kho", "kho" }, { "sla", "sla" }, { "tze", "tze" },
        { "vmp", "vmp" }, { "cst", "cst" }, { "tmb", "tmb" },

        // Synonyms - can add more if you want
        { "skaven", "skv" }, { "nurgle", "nur" },
        { "good", "god" }, { "chaos", "dem" },

        // Group keys - DONT CHANGE THEM
        { "dem", "dem" }, { "bad", "bad" }, { "ded", "ded" }, { "god", "god" },
        { "hmn", "hmn" }, { "elf", "elf" }, { "neu", "neu" }, { "any", "any" }
    };

    public bool Execute()
    {
        string raw = CPH.GetGlobalVar<string>("WHcommand", true);

        if (string.IsNullOrWhiteSpace(raw))
        {
            CPH.SetGlobalVar("WHcommand", "NOT", true);
            CPH.LogInfo("⚠️ WHcommand is empty or not set. Reset to 'NOT'.");
            return true;
        }

        // ===== STATIC COMMAND CHECK =====
        string mapped;
        if (CommandMap.TryGetValue(raw, out mapped))
        {
            CPH.SetGlobalVar("WHcommand", mapped, true);
            CPH.LogInfo($"✅ Static chat command '{raw}' mapped to '{mapped}'");
            return true;
        }

        // ===== DYNAMIC COMMAND CHECK =====
        string dynamicCommand = HandleDynamicCommand(raw);
        if (!string.IsNullOrEmpty(dynamicCommand))
        {
            CPH.SetGlobalVar("WHcommand", dynamicCommand, true);
            CPH.LogInfo($"✅ Dynamic chat command '{raw}' mapped to '{dynamicCommand}'");
            return true;
        }

        // ===== INVALID COMMAND =====
        CPH.SetGlobalVar("WHcommand", "NOT", true);
        CPH.LogInfo($"❌ Invalid chat command '{raw}', WHcommand set to 'NOT'");
        return true;
    }

    private static string HandleDynamicCommand(string input)
    {
        if (string.IsNullOrWhiteSpace(input)) return null;

        // Remove "!WH " prefix if present
        string clean = input.StartsWith("!WH ", StringComparison.OrdinalIgnoreCase) 
            ? input.Substring(4) 
            : input;

        // Split parts
        string[] parts = clean.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
        if (parts.Length == 0) return null;

        // Check if first word is a dynamic keyword
        string keyword = parts[0].ToLower();
        string template;
        if (!DynamicCommandMap.TryGetValue(keyword, out template)) return null;

        // Handle toss_a_coin
        if (template.StartsWith("toss_a_coin_") && parts.Length >= 2)
        {
            int amount;
            if (int.TryParse(parts[1], out amount))
                return "!WH " + string.Format(template, amount);
        }

        // Handle switcharoo
        if (template.StartsWith("switcharoo_") && parts.Length >= 2)
        {
            int number;
            if (int.TryParse(parts[1], out number))
                return "!WH " + string.Format(template, number);
        }

        // Handle spawn_armies
        if (template.StartsWith("spawn_armies_") && parts.Length >= 3)
        {
            int count;
            if (!int.TryParse(parts[parts.Length - 1], out count))
                return null;

            // Combine middle parts as faction/group keyword
            string factionKeyRaw = parts[1];
            for (int i = 2; i < parts.Length - 1; i++)
                factionKeyRaw += "_" + parts[i];
            factionKeyRaw = factionKeyRaw.ToLower();

            // Map synonym to canonical key
            string mappedKey;
            if (!FactionMap.TryGetValue(factionKeyRaw, out mappedKey))
                return null; // Invalid faction/group

            // Return fully mapped command
            return "!WH " + string.Format(template, mappedKey, count);
        }

        return null;
    }
}
